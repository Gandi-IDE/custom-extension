const witcat_more_mouse_picture = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI0NzkuMzg5MDciIGhlaWdodD0iMzU5LjU4OTg0IiB2aWV3Qm94PSIwLDAsNDc5LjM4OTA3LDM1OS41ODk4NCI+PGRlZnM+PGxpbmVhckdyYWRpZW50IHgxPSIyNDAuMDAwMDMiIHkxPSIwLjM2NDIxIiB4Mj0iMjQwLjAwMDAzIiB5Mj0iMzU5LjYzNTgzIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaWQ9ImNvbG9yLTEiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzhlYWNlMSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzg5YTdkYSIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IHgxPSIyNDYuNzM1MTkiIHkxPSIxMTguMDc2NSIgeDI9IjI0OC4yNzY2OCIgeTI9IjIyMC45OTIxNCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGlkPSJjb2xvci0yIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmZmZmYiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNlNWVhZjMiLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC4zMDU0OSwtMC4zNjQyMSkiPjxnIGRhdGEtcGFwZXItZGF0YT0ieyZxdW90O2lzUGFpbnRpbmdMYXllciZxdW90Ozp0cnVlfSIgZmlsbC1ydWxlPSJub256ZXJvIiBzdHJva2Utd2lkdGg9IjAiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgc3Ryb2tlLWRhc2hhcnJheT0iIiBzdHJva2UtZGFzaG9mZnNldD0iMCIgc3R5bGU9Im1peC1ibGVuZC1tb2RlOiBub3JtYWwiPjxwYXRoIGQ9Ik0wLjMwNTQ5LDM1OS42MzU4M3YtMzU5LjI3MTYyaDQ3OS4zODkwN3YzNTkuMjcxNjJ6IiBmaWxsPSJ1cmwoI2NvbG9yLTEpIiBzdHJva2U9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIwMC45OTA5NiwzNTkuMzM3MDlsMTAuMjI3NzYsLTI0MC4xNDk0OGwxOTMuMDc4NTQsMjQwLjc2NjQ0eiIgZmlsbD0iIzcyOGJiNSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ3LjA3OTk5LDIyMS4wMTAwNmwtMTIuNDI0LC0zMC4zMzY0M2wtMjAuMDM5MDcsMjAuNjQ4NWwtMS4zODkxNCwtOTIuNzQzNzNsNjguMDE4NTksNjYuMDExMDZsLTI5LjMxODk4LDAuNDM5MTVsMTEuMDk3NTIsMjkuNjk3NDN6IiBmaWxsPSJ1cmwoI2NvbG9yLTIpIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjIzOS42OTQ1MDYzMjc4NzM5OjE3OS42MzU3OTEwMDI3Mjk3Ny0tPg==";

const witcat_more_mouse_icon = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNzcuMDg4NTUiIGhlaWdodD0iMTc3LjA4ODU1IiB2aWV3Qm94PSIwLDAsMTc3LjA4ODU1LDE3Ny4wODg1NSI+PGRlZnM+PGxpbmVhckdyYWRpZW50IHgxPSIyNDcuMDc3MyIgeTE9IjExOS4xNDIzMSIgeDI9IjI0Ny4wNzczIiB5Mj0iMjIyLjA2OTQ4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaWQ9ImNvbG9yLTEiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2U1ZWFmMyIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNTEuNDU1NzYsLTkxLjQ1NTc0KSI+PGcgZGF0YS1wYXBlci1kYXRhPSJ7JnF1b3Q7aXNQYWludGluZ0xheWVyJnF1b3Q7OnRydWV9IiBmaWxsLXJ1bGU9Im5vbnplcm8iIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1kYXNob2Zmc2V0PSIwIiBzdHlsZT0ibWl4LWJsZW5kLW1vZGU6IG5vcm1hbCI+PHBhdGggZD0iTTE1MS40NTU3NiwyNjguNTQ0Mjl2LTE3Ny4wODg1NWgxNzcuMDg4NTV2MTc3LjA4ODU1eiIgZmlsbD0iIzhlYWNlMSIgc3Ryb2tlPSJub25lIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzguMjAwNywyNDAuODU3NjlsLTEwLjQ4NDQxLC0zNS4xNjgwMmwtMjEuMzAyNDQsMjEuOTAwNjJsNC40Njc1OCwtMTA0Ljg5OTUxbDYzLjcxNjM3LDc5LjQ1MzQ5bC0yOS4yODgyNCwtMS41OTkxMmw5LjIwMDkxLDM0LjM1MTE1eiIgZmlsbD0iIzcyOGJiNSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ1Ljg4MDQ3LDIyMi4wNjk0OGwtMTEuOTY4MjcsLTMwLjUxOTFsLTIwLjM0NjA3LDIwLjM0NjA3di05Mi43NTQxM2w2Ny4wMjIzNCw2Ny4wMjIzNGgtMjkuMzIyMjdsMTAuNjUxNTEsMjkuODYwM3oiIGZpbGw9InVybCgjY29sb3ItMSkiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6ODguNTQ0MjQ0OTk5OTk5OTk6ODguNTQ0MjU1LS0+";

const witcat_more_mouse_extensionId = "WitCatMouse";

/** @typedef {string|number} SCarg 来自Scratch圆形框的参数，虽然这个框可能只能输入数字，但是可以放入变量，因此有可能获得数字和文本，需要同时处理 */

class WitCatMouse {
	constructor(runtime) {
		/**
		 * 鼠标键是否按下
		 * @type {("up"|"down")[]}
		 */
		this.button = ["up", "up", "up", "up", "up"];

		/**
		 * 鼠标x移动速度
		 */
		this.xMouse = 0;

		/**
		 * 鼠标y移动速度
		 */
		this.yMouse = 0;

		/**
		 * 鼠标滚轮速度
		 */
		this.MouseWheel = 0;

		/**
		 * 鼠标速度重置计时器
		 * @type {null|number}
		 */
		this.timer = null;

		/**
		 * 手指列表
		 * @type {{identifier: number|"mouse", clientX: number, clientY: number}[]}
		 */
		this.touch = [];

		/**
		 * 点击事件计时器
		 * @type {false|number}
		 */
		this.click = false;

		/**
		 * 双击事件计时器
		 * @type {false|number}
		 */
		this.dclick = false;

		/**
		 * 鼠标按下计时器(记录按下鼠标的时刻)
		 * @type {(""|number)[]}
		 */
		this.mousetdlist = ["", "", "", "", ""];

		/**
		 * Scratch 所使用的 canvas，获取不到返回 null
		 * @return {HTMLCanvasElement | null}
		 */
		this.canvas = () => {
			try {
				const canvas = runtime.renderer.canvas;
				if (canvas instanceof HTMLCanvasElement) {
					return canvas;
				} else {
					return null;
				}
			} catch (err) {
				return null;
			}
		};

		if (this.canvas() === null) {
			alert("当前页面不支持多指触控/全屏，请前往作品详情页体验完整作品！");
			// 注意：在提示之后，扩展仍然在运行。需要在后面引用 Canvas 的部分进行判断。
		}
		this._addevent();

		this.runtime = runtime;
		this._formatMessage = runtime.getFormatMessage({
			"zh-cn": {
				"WitCatMouse.name": "[beta]白猫的高级鼠标",
				"WitCatMouse.name.1": "高级鼠标",
				"WitCatMouse.name.2": "多指触控",
				"WitCatMouse.set": "[set]右键菜单",
				"WitCatMouse.set.1": "启用",
				"WitCatMouse.set.2": "禁用",
				"WitCatMouse.when": "鼠标[key]被按下",
				"WitCatMouse.key.1": "左键",
				"WitCatMouse.key.2": "中键",
				"WitCatMouse.key.3": "右键",
				"WitCatMouse.key.4": "前侧键",
				"WitCatMouse.key.5": "后侧键",
				"WitCatMouse.mouseuse": "[mouseuse]鼠标",
				"WitCatMouse.mouseuse.1": "锁定",
				"WitCatMouse.mouseuse.2": "释放",
				"WitCatMouse.acceleration": "鼠标[way]速度",// 速度和加速度的区别
				"WitCatMouse.way.1": "X",
				"WitCatMouse.way.2": "Y",
				"WitCatTouch.down": "按下的手指数量",
				"WitCatTouch.num": "第[num]个手指的[type]",
				"WitCatTouch.type.1": "X",
				"WitCatTouch.type.2": "Y",
				"WitCatTouch.type.3": "ID",
				"WitCatMouse.fill": "[set]沉浸式全屏",
				"WitCatMouse.fillask.1": "作品请求沉浸式全屏，是否同意？\n",
				"WitCatMouse.fillask.2": "/3次连续拒绝后将不再提示\n您仍可以使用 ctrl+shift+alt 切换沉浸式全屏状态",
				"WitCatMouse.setfill": "⚠️(危)设置分辨率高设为[num]",
				"WitCatMouse.resolution": "当前分辨率高",
				"WitCatMouse.cantouch": "设备支持[type]?",
				"WitCatMouse.types.1": "触屏",
				"WitCatMouse.types.2": "鼠标",
				"WitCatMouse.IsMobile": "移动设备?",
				"WitCatMouse.cursor": "更改鼠标的样式为[cursor]",
				"WitCatMouse.cursor.1": "默认",
				"WitCatMouse.cursor.2": "文本",
				"WitCatMouse.cursor.3": "十字移动",
				"WitCatMouse.cursor.4": "上下移动",
				"WitCatMouse.cursor.5": "左右移动",
				"WitCatMouse.cursor.6": "禁止",
				"WitCatMouse.cursor.7": "手指",
				"WitCatMouse.cursor.8": "加载",
				"WitCatMouse.cursor.9": "等待",
				"WitCatMouse.cursor.10": "帮助",
				"WitCatMouse.cursor.11": "竖向文本",
				"WitCatMouse.cursor.12": "十字准星",
				"WitCatMouse.cursorurl": "更改鼠标的样式为X[x]Y[y]data url[text]",
				"WitCatMouse.url": "上传ico并获得data url",
				"WitCatMouse.click": "点击",
				"WitCatMouse.dclick": "双击",
				"WitCatMouse.mouse": "鼠标被[way]?",
				"WitCatMouse.mousetd": "当鼠标[key]按住[time]秒",
				"WitCatMouse.mouset": "鼠标[key]按下时长(秒)",
				"WitCatMouse.docs": "📖拓展教程",
				"WitCatMouse.mousewheel": "鼠标滚轮速度",
			},
			en: {
				"WitCatMouse.name": "[beta]WitCat’s Mouse",
				"WitCatMouse.name.1": "more mouse",
				"WitCatMouse.name.2": "more touch",
				"WitCatMouse.set": "[set]right-click menu",
				"WitCatMouse.set.1": "Enable",
				"WitCatMouse.set.2": "Disable",
				"WitCatMouse.when": "mouse[key]down?",
				"WitCatMouse.key.1": "left button",
				"WitCatMouse.key.2": "middle button",
				"WitCatMouse.key.3": "right button",
				"WitCatMouse.key.4": "first side button",
				"WitCatMouse.key.5": "second side button",
				"WitCatMouse.mouseuse": "[mouseuse]mouse",
				"WitCatMouse.mouseuse.1": "Lock",
				"WitCatMouse.mouseuse.2": "Release",
				"WitCatMouse.acceleration": "mouse[way]speed",
				"WitCatMouse.way.1": "X",
				"WitCatMouse.way.2": "Y",
				"WitCatTouch.name": "Touch",
				"WitCatTouch.down": "Finger count",
				"WitCatTouch.num": "[type]of finger[num]",
				"WitCatTouch.type.1": "X",
				"WitCatTouch.type.2": "Y",
				"WitCatTouch.type.3": "ID",
				"WitCatMouse.fill": "[set]immersive full-screen",
				"WitCatMouse.fillask.1": "The project requests to turn on immersive full-screen, agree or not?\nWill stop asking if you keep on to reject for ",
				"WitCatMouse.fillask.2": "/3 times\nYou can also use Ctrl+Shift+Alt to toggle immersive full-screen later.",
				"WitCatMouse.setfill": "⚠️(danger)Set resolution height to[num]",
				"WitCatMouse.resolution": "Current high resolution",
				"WitCatMouse.cantouch": "Device support[type]?",
				"WitCatMouse.types.1": "touch screen",
				"WitCatMouse.types.2": "mouse",
				"WitCatMouse.IsMobile": "Mobile device?",
				"WitCatMouse.cursor": "Change cursor style to[cursor]",
				"WitCatMouse.cursor.1": "default",
				"WitCatMouse.cursor.2": "text",
				"WitCatMouse.cursor.3": "cross move",
				"WitCatMouse.cursor.4": "move up and down",
				"WitCatMouse.cursor.5": "move left and right",
				"WitCatMouse.cursor.6": "not allowed",
				"WitCatMouse.cursor.7": "pointer",
				"WitCatMouse.cursor.8": "progress",
				"WitCatMouse.cursor.9": "wait",
				"WitCatMouse.cursor.10": "help",
				"WitCatMouse.cursor.11": "vertical text",
				"WitCatMouse.cursor.12": "crosshair",
				"WitCatMouse.cursorurl": "Change the style of the mouse to X[x]Y[y]base64[text]",
				"WitCatMouse.url": "upload ico and get base64",
				"WitCatMouse.click": "click",
				"WitCatMouse.dclick": "double-click",
				"WitCatMouse.mouse": "mouse[way]?",
				"WitCatMouse.mousetd": "When mouse[key]pressed[time]seconds",
				"WitCatMouse.mouset": "mouse[key]hold time(sec)",
				"WitCatMouse.docs": "📖Tutorials",
				"WitCatInput.mousewheel": "mouse wheel speed",
			}
		})
	}

	/**
	 * 翻译
	 * @param {string} id
	 * @returns {string}
	 */
	formatMessage(id) {
		return this._formatMessage({
			id,
			default: id,
			description: id
		});
	}

	getInfo() {
		return {
			id: witcat_more_mouse_extensionId, // 拓展id
			name: this.formatMessage("WitCatMouse.name"), // 拓展名
			blockIconURI: witcat_more_mouse_icon,
			menuIconURI: witcat_more_mouse_icon,
			color1: "#8eace1",
			color2: "#86a2d4",
			blocks: [
				{
					blockType: "button",
					text: this.formatMessage('WitCatMouse.docs'),
					onClick: this.docs,
				},
				{
					opcode: 'setfill',
					blockType: "command",
					text: this.formatMessage("WitCatMouse.setfill"),
					hideFromPalette: true,
					arguments: {
						num: {
							type: "number",
							defaultValue: "360",
						},
					}
				},
				{
					opcode: 'fill',
					blockType: "command",
					text: this.formatMessage("WitCatMouse.fill"),
					hideFromPalette: true,
					arguments: {
						set: {
							type: "bool",
							menu: "set",
						},
					}
				},
				{
					opcode: 'resolution',
					blockType: "reporter",
					text: this.formatMessage("WitCatMouse.resolution"),
					arguments: {}
				},
				"---" + this.formatMessage("WitCatMouse.name.1"),
				{
					opcode: 'set',
					blockType: "command",
					text: this.formatMessage("WitCatMouse.set"),
					arguments: {
						set: {
							type: "bool",
							menu: "set",
						},
					}
				},
				{
					opcode: "when",
					blockType: "Boolean",
					text: this.formatMessage("WitCatMouse.when"),
					arguments: {
						key: {
							type: "string",
							menu: "key",
						},
					},
				},
				{
					opcode: "mouses",
					blockType: "Boolean",
					text: this.formatMessage("WitCatMouse.mouse"),
					arguments: {
						way: {
							type: "string",
							menu: "ways",
						},
					},
				},
				{
					opcode: "mousewheel",
					blockType: "reporter",
					text: this.formatMessage("WitCatMouse.mousewheel"),
					arguments: {},
				},
				{
					opcode: "mouse",
					blockType: "hat",
					text: this.formatMessage("WitCatMouse.mouse"),
					arguments: {
						way: {
							type: "string",
							menu: "ways",
						},
					},
				},
				{
					opcode: "mousetd",
					blockType: "Boolean",
					text: this.formatMessage("WitCatMouse.mousetd"),
					arguments: {
						key: {
							type: "number",
							menu: "key",
						},
						time: {
							type: "number",
							defaultValue: "1",
						},
					},
				},
				{
					opcode: "mousetds",
					blockType: "hat",
					text: this.formatMessage("WitCatMouse.mousetd"),
					arguments: {
						key: {
							type: "number",
							menu: "key",
						},
						time: {
							type: "number",
							defaultValue: "1",
						},
					},
				},
				{
					opcode: "mouset",
					blockType: "reporter",
					text: this.formatMessage("WitCatMouse.mouset"),
					arguments: {
						key: {
							type: "number",
							menu: "key",
						},
					},
				},
				{
					blockType: "button",
					text: this.formatMessage('WitCatMouse.url'),
					// 这里的 bind 必须，因为 this.url 里面引用了 this
					onClick: this.url.bind(this),
				},
				{
					opcode: "cursor",
					blockType: "command",
					text: this.formatMessage("WitCatMouse.cursor"),
					arguments: {
						cursor: {
							type: "string",
							menu: "cursor",
						},
					},
				},
				{
					opcode: "cursorurl",
					blockType: "command",
					text: this.formatMessage("WitCatMouse.cursorurl"),
					arguments: {
						x: {
							type: "string",
							defaultValue: "0",
						},
						y: {
							type: "string",
							defaultValue: "0",
						},
						text: {
							type: "string",
							defaultValue: "base64:ico",
						},
					},
				},
				{
					opcode: "mouseuse",
					blockType: "command",
					text: this.formatMessage("WitCatMouse.mouseuse"),
					arguments: {
						mouseuse: {
							type: "string",
							menu: "mouseuse",
						},
					},
				},
				{
					opcode: "acceleration",
					blockType: "reporter",
					text: this.formatMessage("WitCatMouse.acceleration"),
					arguments: {
						way: {
							type: "string",
							menu: "way",
						},
					},
				},
				"---" + this.formatMessage("WitCatMouse.name.2"),
				{
					opcode: 'down',
					blockType: "reporter",
					text: this.formatMessage("WitCatTouch.down"),
					arguments: {}
				},
				{
					opcode: "num",
					blockType: "reporter",
					text: this.formatMessage("WitCatTouch.num"),
					arguments: {
						num: {
							type: "number",
							defaultValue: "1",
						},
						type: {
							type: "string",
							menu: "type",
						},
					},
				},
				{
					opcode: "cantouch",
					blockType: "Boolean",
					text: this.formatMessage("WitCatMouse.cantouch"),
					arguments: {
						type: {
							type: "string",
							menu: "types",
						},
					},
				},
				{
					opcode: "IsMobile",
					blockType: "Boolean",
					text: this.formatMessage("WitCatMouse.IsMobile"),
					arguments: {},
				},
			],
			menus: {
				key: [
					{
						text: this.formatMessage('WitCatMouse.key.1'),
						value: '0'
					},
					{
						text: this.formatMessage('WitCatMouse.key.2'),
						value: '1'
					},
					{
						text: this.formatMessage('WitCatMouse.key.3'),
						value: '2'
					},
					{
						text: this.formatMessage('WitCatMouse.key.4'),
						value: '3'
					},
					{
						text: this.formatMessage('WitCatMouse.key.5'),
						value: '4'
					},
				],
				cursor: {
					acceptReporters: true,
					items: [
						{
							text: this.formatMessage('WitCatMouse.cursor.1'),
							value: 'default'
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.2'),
							value: 'text'
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.3'),
							value: 'move'
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.4'),
							value: 'n-resize'
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.5'),
							value: 'e-resize'
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.6'),
							value: 'not-allowed'
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.7'),
							value: 'pointer'
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.8'),
							value: 'progress'
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.9'),
							value: 'wait'
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.10'),
							value: 'help'
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.11'),
							value: 'vertical-text'
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.12'),
							value: 'crosshair'
						},
					],
				},
				set: [
					{
						text: this.formatMessage('WitCatMouse.set.1'),
						value: "true"
					},
					{
						text: this.formatMessage('WitCatMouse.set.2'),
						value: "false"
					},
				],
				way: [
					{
						text: this.formatMessage('WitCatMouse.way.1'),
						value: "x"
					},
					{
						text: this.formatMessage('WitCatMouse.way.2'),
						value: "y"
					},
				],
				ways: [
					{
						text: this.formatMessage('WitCatMouse.click'),
						value: "click"
					},
					{
						text: this.formatMessage('WitCatMouse.dclick'),
						value: "dclick"
					},
				],
				type: [
					{
						text: this.formatMessage('WitCatTouch.type.1'),
						value: "x"
					},
					{
						text: this.formatMessage('WitCatTouch.type.2'),
						value: "y"
					},
					{
						text: this.formatMessage('WitCatTouch.type.3'),
						value: "ID"
					},
				],
				types: [
					{
						text: this.formatMessage('WitCatMouse.types.1'),
						value: "ontouchstart"
					},
					{
						text: this.formatMessage('WitCatMouse.types.2'),
						value: "onmousedown"
					},
				],
				mouseuse: [
					{
						text: this.formatMessage('WitCatMouse.mouseuse.1'),
						value: "lock"
					},
					{
						text: this.formatMessage('WitCatMouse.mouseuse.2'),
						value: "release"
					},
				],
			}
		};
	}

	/**
	 * 启用右键菜单？
	 * @param {object} args
	 * @param {SCarg} args.set
	 */
	set(args) {
		const canvas = this.canvas();
		if (canvas === null) {
			return;
		}
		// 在把自己的方法设为给其他事件/函数的回调时加上 bind(this) 是很有必要的，
		// 确保回调函数触发时，里面的 this 指向自己。
		// 不过回调函数里面没有用到 this，所以是否有这个 bind 没有区别。
		// 如果加上了 bind，因为每次 bind() 都会生成一个新函数，
		// removeEventListener 的时候就会因为函数不一致导致 remove 不掉，
		// 需要提前把 bind 过的函数设为某类内变量。
		if (args.set === "false") {
			canvas.addEventListener("contextmenu", this._nocontextmenu);
		} else {
			canvas.removeEventListener("contextmenu", this._nocontextmenu);
		}
	}

	/**
	 * 禁用右键菜单用的事件捕获函数
	 * @param {Event} event
	 */
	_nocontextmenu(event) {
		// 阻止右键菜单
		event.preventDefault();
	}

	/**
	 * 按下判断
	 * @param {object} args
	 * @param {SCarg} args.key
	 */
	when(args) {
		return this.button[Number(args.key)] === "down";
	}

	/**
	 * 控制鼠标
	 * @param {object} args
	 * @param {SCarg} args.mouseuse
	 */
	mouseuse(args) {
		if (args.mouseuse === "release") {
			document.exitPointerLock();
		}
		else {
			document.body.requestPointerLock();
		}
	}

	/**
	 * 鼠标移动量
	 * @param {object} args
	 * @param {SCarg} args.way
	 * @returns {number}
	 */
	acceleration(args) {
		if (args.way === "x") {
			return this.xMouse;
		}
		else {
			return -this.yMouse;
		}
	}

	/**
	 * 手指数量
	 * @returns {number}
	 */
	down() {
		return this.touch.length;
	}

	/**
	 * 坐标
	 * @param {object} args
	 * @param {SCarg} args.num 手指编号
	 * @param {SCarg} args.type 数据类型 "x"|"y"|"identifier"
	 * @returns {number|string}
	 */
	num(args) {
		const canvas = this.canvas();
		if (canvas === null) {
			return 0;
		}
		const touch1 = this.touch[Number(args.num) - 1];
		if (touch1 !== undefined) {
			if (args.type === "x") {
				return this.runtime.stageWidth * ((touch1.clientX - canvas.getBoundingClientRect().left) / canvas.offsetWidth);
			}
			else if (args.type === "y") {
				return this.runtime.stageHeight * ((touch1.clientY - canvas.getBoundingClientRect().top) / canvas.offsetHeight);
			}
			else {
				return touch1.identifier;
			}
		}
		else {
			return 0;
		}
	}

	/**
	 * 全屏
	 * @deprecated
	 */
	fill() {
		console.warn("全屏因浏览器兼容问题已下线，在未来修复后将会重新上线\nFull screen has been taken offline due to browser compatibility issues. It will be back online after a future fix");
	}

	/**
	 * 设置分辨率
	 * @deprecated
	 */
	setfill() {
		console.warn("全屏因浏览器兼容问题已下线，在未来修复后将会重新上线\nFull screen has been taken offline due to browser compatibility issues. It will be back online after a future fix");
	}

	/**
	 * 当前分辨率
	 * @returns {number}
	 */
	resolution() {
		const canvas = this.canvas();
		if (canvas === null) {
			return 0;
		}
		return canvas.height;
	}

	/**
	 * 设备是否支持触屏/鼠标
	 * @param {object} args
	 * @param {SCarg} args.type
	 * @returns {boolean}
	 */
	cantouch(args) {
		return (args.type in document.documentElement);
	}

	/**
	 * 是否是手机
	 * @returns {boolean}
	 */
	IsMobile() {
		return /Android|iPhone|iPad|iPod|BlackBerry|webOS|Windows Phone|SymbianOS|IEMobile|Opera Mini/i.test(navigator.userAgent);
	}

	/**
	 * 设置光标样式
	 * @param {object} args
	 * @param {SCarg} args.cursor 样式
	 */
	cursor(args) {
		const canvasParent = this.canvas()?.parentNode?.parentNode?.parentNode;
		if (canvasParent === null || canvasParent === undefined) {
			return;
		}
		canvasParent.style.cursor = String(args.cursor);
	}

	/**
	 * 设置光标为url
	 * @param {object} args
	 * @param {SCarg} args.text 样式
	 * @param {SCarg} args.x x偏移
	 * @param {SCarg} args.y y偏移
	 */
	cursorurl(args) {
		const canvasParent = this.canvas()?.parentNode?.parentNode?.parentNode;
		if (canvasParent === null || canvasParent === undefined) {
			return;
		}
		let url = String(args.text);
		const x = Number(args.x);
		const y = Number(args.y);
		// 针对 url() 里的语法，转义。
		url = url.replace(/"/g, "%22").replace(/\n/g, "%0D")
			.replace(/\r/g, "%0A").replace(/\0/g, "%00");
		// 实际上 cursorurl 处可以直接使用 正常的 url 和 data url。
		// 不需要特地转换。
		canvasParent.style.cursor = `url("${url}") ${x} ${y}, auto`;
	}

	/**
	 * 打开文件选择框
	 * @param {string} accept 接受的文件扩展名
	 * @param {boolean} multiple 接受多个文件
	 * @return {Promise<File[]>} [异步地]返回选择后的文件列表input.files转换成的数组(可能没有文件)
	 */
	_inputfileclick(accept, multiple) {
		return new Promise((resolve, reject) => {
			const input = document.createElement("input");
			input.type = "file";
			input.accept = accept;
			input.style.display = "none";
			input.multiple = multiple;
			input.click();
			input.addEventListener("change", () => {
				if (input.files === null) {
					reject(new Error("不应该看到这个"));
				} else {
					// 返回了关键的 input.files，而不是整个 input。
					// 之后如果要考虑“读取素材库文件”，“拖动导入文件”等
					// 只能获得 Blob/File 的情况，可以方便适配
					// 这里加 Array.from 是因为 input.files 是 FileList，
					// 不是 File[]，一些数组拥有的功能它没有。虽然一般情况下
					// 不会注意到区别，但是类型检查会把这种情况查出来。
					resolve(Array.from(input.files));
				}
			}, { once: true }); // 只触发一次
			window.addEventListener("focus", () => {
				setTimeout(() => {
					if (input.files === null) {
						reject(new Error("不应该看到这个"));
					} else {
						resolve(Array.from(input.files));
					}
				}, 1000);
			}, { once: true }); // 只触发一次
		});
	}

	/**
	 * 读取文件
	 * @param {File|Blob} file File 或者 Blob
	 * @param {"arraybuffer"|"dataurl"|"text"} mode 读取模式
	 * @return {Promise<string|ArrayBuffer|null>} [异步地]返回读取后的内容
	 */
	_readerasync(file, mode) {
		return new Promise((resolve, reject) => {
			const reader = new FileReader();
			reader.onload = () => {
				resolve(reader.result);
			};
			reader.onerror = (e) => {
				reject(e);
			};
			switch (mode) {
				case "arraybuffer":
					reader.readAsArrayBuffer(file);
					break;
				case "dataurl":
					reader.readAsDataURL(file);
					break;
				case "text":
					reader.readAsText(file);
					break;
				default:
					reject(new Error("mode 错误: 应该是 arraybuffer, dataurl 或者 text"));
					return;
			}
		});
	}

	/**
	 * 打开ico文件
	 */
	async url() {
		const file = (await this._inputfileclick(".ico", false))[0];
		if (file !== undefined) {
			// 加一个扩展名判断？
			const dataurl = String(await this._readerasync(file, "dataurl"));
			prompt("请复制以下代码：", dataurl);
		}
	}

	/**
	 * 打开教程
	 */
	docs() {
		let a = document.createElement('a');
		a.href = "https://www.ccw.site/post/c36aa805-b29d-48da-aba1-468a6cf80bfa";
		a.rel = "noopener noreferrer";
		a.target = "_blank";
		a.click();
	}

	/**
	 * 鼠标点击/双击
	 * @param {object} args
	 * @param {SCarg} args.way 点击/双击
	 * @returns {boolean}
	 */
	mouse(args) {
		if (args.way === "click") {
			return this.click !== false;
		}
		if (args.way === "dclick") {
			return this.dclick !== false;
		}
		return false;
	}

	/**
	 * 鼠标滚轮速度
	 * @returns {number}
	 */
	mousewheel() {
		return this.MouseWheel;
	}

	/**
	 * 鼠标点击/双击(帽子积木)
	 * @param {object} args
	 * @param {SCarg} args.way 点击/双击
	 * @returns {boolean}
	 */
	mouses(args) {
		return this.mouse(args);
	}

	/**
	 * 判断鼠标键按下时长
	 * @param {object} args
	 * @param {SCarg} args.key 按键编号
	 * @param {SCarg} args.time 按键时长
	 * @returns {boolean}
	 */
	mousetd(args) {
		const mousetdkey = this.mousetdlist[Number(args.key)];
		if (mousetdkey !== undefined && mousetdkey != "") {
			let time = Date.now() - (Number(args.time) * 1000 + mousetdkey);
			if (-50 <= time && time <= 50) {
				return true;
			}
		}
		return false;
	}

	/**
	 * 判断鼠标键按下时长(帽子积木)
	 * @param {object} args
	 * @param {SCarg} args.key 按键编号
	 * @param {SCarg} args.time 按键时长
	 * @returns {boolean}
	 */
	mousetds(args) {
		return this.mousetd(args);
	}

	/**
	 * 鼠标被按下的时间
	 * @param {object} args
	 * @param {SCarg} args.key 按键编号
	 * @returns {number}
	 */
	mouset(args) {
		const mousetdkey = this.mousetdlist[Number(args.key)];
		if (mousetdkey !== undefined && mousetdkey != "") {
			return (Date.now() - mousetdkey) / 1000;
		}
		return 0;
	}

	/**
	 * 复制触摸点数
	 * @param {TouchList} touches
	 */
	_copytouch(touches) {
		this.touch = Array.from(touches).map((touch) => {
			return {
				clientX: touch.clientX,
				clientY: touch.clientY,
				identifier: touch.identifier
			}
		});
	}

	/** 添加事件触发器 */
	_addevent() {
		const canvas = this.canvas();
		if (canvas === null) {
			return;
		}
		//鼠标
		canvas.addEventListener('mousedown', e => {
			this.button[e.button] = "down";
			this.mousetdlist[e.button] = Date.now();
			if (this.button[0] === "down") {
				this.touch = [{
					clientX: e.clientX,
					clientY: e.clientY,
					identifier: "mouse"
				}];
			}
		})
		document.addEventListener('mouseup', e => {
			this.button[e.button] = "up";
			this.mousetdlist[e.button] = "";
			this.touch = [];
		})
		document.addEventListener("mousemove", ev => {
			if (this.button[0] === "down") {
				this.touch = [{
					clientX: ev.clientX,
					clientY: ev.clientY,
					identifier: "mouse"
				}];
			}
			else {
				this.touch = [];
			}
			this.xMouse = ev.movementX; // 获得鼠标指针的x移动量
			this.yMouse = ev.movementY; // 获得鼠标指针的y移动量
			if (this.timer !== null) {
				clearTimeout(this.timer);
			}
			this.timer = setTimeout(() => {
				this.xMouse = 0;
				this.yMouse = 0;
			}, 30);
		});
		//多指触控
		canvas.addEventListener('touchstart', e => {
			// e.targetTouches 会随着时间改变，必须复制一份。
			this._copytouch(e.targetTouches);
			this.button[0] = "down";
			this.mousetdlist[0] = Date.now();
		})
		canvas.addEventListener('touchmove', e => {
			if (e.targetTouches[0] !== undefined && this.touch[0] !== undefined) {
				this.xMouse = e.targetTouches[0].clientX - this.touch[0].clientX; // 获得手指的x移动量
				this.yMouse = e.targetTouches[0].clientY - this.touch[0].clientY; // 获得手指的y移动量
			}
			if (this.timer !== null) {
				clearTimeout(this.timer);
			}
			this.timer = setTimeout(() => {
				this.xMouse = 0;
				this.yMouse = 0;
			}, 30);
			// e.targetTouches 会随着时间改变，必须复制一份。
			this._copytouch(e.targetTouches);
		})
		canvas.addEventListener('touchend', e => {
			// e.targetTouches 会随着时间改变，必须复制一份。
			this._copytouch(e.targetTouches);
			this.mousetdlist[0] = "";
			this.button[0] = "up";
		})
		canvas.addEventListener('click', () => {
			if (this.click !== false) {
				clearTimeout(this.click);
			}
			this.click = setTimeout(() => {
				this.click = false;
			}, 50);
		});
		canvas.addEventListener('dblclick', () => {
			if (this.dclick !== false) {
				clearTimeout(this.dclick);
			}
			this.dclick = setTimeout(() => {
				this.dclick = false;
			}, 50);
		});
		//给页面绑定滑轮滚动事件
		canvas.addEventListener('wheel', (e) => {
			this.MouseWheel = e.deltaY;
			if (this.timer !== null) {
				clearTimeout(this.timer);
			}
			this.timer = setTimeout(() => {
				this.MouseWheel = 0;
			}, 30);
		}, { capture: true });
	}
}

window.tempExt = {
	Extension: WitCatMouse,
	info: {
		name: "WitCatMouse.name",
		description: "WitCatMouse.descp",
		extensionId: witcat_more_mouse_extensionId,
		iconURL: witcat_more_mouse_picture,
		insetIconURL: witcat_more_mouse_icon,
		featured: true,
		disabled: false,
		collaborator: "白猫 @ CCW"
	},
	l10n: {
		"zh-cn": {
			"WitCatMouse.name": "[beta]白猫的高级鼠标",
			"WitCatMouse.descp": "更精准的控制鼠标/触屏/全屏！"
		},
		en: {
			"WitCatMouse.name": "[beta]WitCat’s Mouse",
			"WitCatMouse.descp": "More precise mouse/touch/full screen control!"
		}
	}
};
