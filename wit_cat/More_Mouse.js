const witcat_more_mouse_picture = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI0NzkuMzg5MDciIGhlaWdodD0iMzU5LjU4OTg0IiB2aWV3Qm94PSIwLDAsNDc5LjM4OTA3LDM1OS41ODk4NCI+PGRlZnM+PGxpbmVhckdyYWRpZW50IHgxPSIyNDAuMDAwMDMiIHkxPSIwLjM2NDIxIiB4Mj0iMjQwLjAwMDAzIiB5Mj0iMzU5LjYzNTgzIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaWQ9ImNvbG9yLTEiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzhlYWNlMSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzg5YTdkYSIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IHgxPSIyNDYuNzM1MTkiIHkxPSIxMTguMDc2NSIgeDI9IjI0OC4yNzY2OCIgeTI9IjIyMC45OTIxNCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGlkPSJjb2xvci0yIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmZmZmYiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNlNWVhZjMiLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC4zMDU0OSwtMC4zNjQyMSkiPjxnIGRhdGEtcGFwZXItZGF0YT0ieyZxdW90O2lzUGFpbnRpbmdMYXllciZxdW90Ozp0cnVlfSIgZmlsbC1ydWxlPSJub256ZXJvIiBzdHJva2Utd2lkdGg9IjAiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgc3Ryb2tlLWRhc2hhcnJheT0iIiBzdHJva2UtZGFzaG9mZnNldD0iMCIgc3R5bGU9Im1peC1ibGVuZC1tb2RlOiBub3JtYWwiPjxwYXRoIGQ9Ik0wLjMwNTQ5LDM1OS42MzU4M3YtMzU5LjI3MTYyaDQ3OS4zODkwN3YzNTkuMjcxNjJ6IiBmaWxsPSJ1cmwoI2NvbG9yLTEpIiBzdHJva2U9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIwMC45OTA5NiwzNTkuMzM3MDlsMTAuMjI3NzYsLTI0MC4xNDk0OGwxOTMuMDc4NTQsMjQwLjc2NjQ0eiIgZmlsbD0iIzcyOGJiNSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ3LjA3OTk5LDIyMS4wMTAwNmwtMTIuNDI0LC0zMC4zMzY0M2wtMjAuMDM5MDcsMjAuNjQ4NWwtMS4zODkxNCwtOTIuNzQzNzNsNjguMDE4NTksNjYuMDExMDZsLTI5LjMxODk4LDAuNDM5MTVsMTEuMDk3NTIsMjkuNjk3NDN6IiBmaWxsPSJ1cmwoI2NvbG9yLTIpIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjIzOS42OTQ1MDYzMjc4NzM5OjE3OS42MzU3OTEwMDI3Mjk3Ny0tPg==";

const witcat_more_mouse_icon = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNzcuMDg4NTUiIGhlaWdodD0iMTc3LjA4ODU1IiB2aWV3Qm94PSIwLDAsMTc3LjA4ODU1LDE3Ny4wODg1NSI+PGRlZnM+PGxpbmVhckdyYWRpZW50IHgxPSIyNDcuMDc3MyIgeTE9IjExOS4xNDIzMSIgeDI9IjI0Ny4wNzczIiB5Mj0iMjIyLjA2OTQ4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaWQ9ImNvbG9yLTEiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2U1ZWFmMyIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNTEuNDU1NzYsLTkxLjQ1NTc0KSI+PGcgZGF0YS1wYXBlci1kYXRhPSJ7JnF1b3Q7aXNQYWludGluZ0xheWVyJnF1b3Q7OnRydWV9IiBmaWxsLXJ1bGU9Im5vbnplcm8iIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1kYXNob2Zmc2V0PSIwIiBzdHlsZT0ibWl4LWJsZW5kLW1vZGU6IG5vcm1hbCI+PHBhdGggZD0iTTE1MS40NTU3NiwyNjguNTQ0Mjl2LTE3Ny4wODg1NWgxNzcuMDg4NTV2MTc3LjA4ODU1eiIgZmlsbD0iIzhlYWNlMSIgc3Ryb2tlPSJub25lIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzguMjAwNywyNDAuODU3NjlsLTEwLjQ4NDQxLC0zNS4xNjgwMmwtMjEuMzAyNDQsMjEuOTAwNjJsNC40Njc1OCwtMTA0Ljg5OTUxbDYzLjcxNjM3LDc5LjQ1MzQ5bC0yOS4yODgyNCwtMS41OTkxMmw5LjIwMDkxLDM0LjM1MTE1eiIgZmlsbD0iIzcyOGJiNSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ1Ljg4MDQ3LDIyMi4wNjk0OGwtMTEuOTY4MjcsLTMwLjUxOTFsLTIwLjM0NjA3LDIwLjM0NjA3di05Mi43NTQxM2w2Ny4wMjIzNCw2Ny4wMjIzNGgtMjkuMzIyMjdsMTAuNjUxNTEsMjkuODYwM3oiIGZpbGw9InVybCgjY29sb3ItMSkiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6ODguNTQ0MjQ0OTk5OTk5OTk6ODguNTQ0MjU1LS0+";

const witcat_more_mouse_extensionId = 'WitCatMouse';

/** @typedef {string|number} SCarg 来自Scratch圆形框的参数，虽然这个框可能只能输入数字，但是可以放入变量，因此有可能获得数字和文本，需要同时处理 */

class WitCatMouse {
	constructor(runtime) {
		/**
		 * 鼠标键是否按下
		 * @type {("up"|"down")[]}
		 */
		this.button = ['up', 'up', 'up', 'up', 'up'];

		/**
		 * 鼠标x移动速度
		 */
		this.xMouse = 0;

		/**
		 * 鼠标y移动速度
		 */
		this.yMouse = 0;
		/**
		* 鼠标x
		*/
		this.MouseX = 0;

		/**
		 * 鼠标y
		 */
		this.MouseY = 0;

		/**
		 * 鼠标滚轮速度
		 */
		this.MouseWheel = 0;

		/**
		 * 上次设置分辨率的时间
		 */
		this.LastSet = 0;

		/**
		 * 鼠标速度重置计时器
		 * @type {null|number}
		 */
		this.timer = null;

		/**
		 * 手指列表
		 * @type {{identifier: number|"mouse", clientX: number, clientY: number}[]}
		 */
		this.touch = [];

		/**
		 * 点击事件计时器
		 * @type {false|number}
		 */
		this.click = false;

		/**
		 * 双击事件计时器
		 * @type {false|number}
		 */
		this.dclick = false;

		/**
		 * 鼠标按下计时器(记录按下鼠标的时刻)
		 * @type {(""|number)[]}
		 */
		this.mousetdlist = ['', '', '', '', ''];

		/**
		 * 获取的手机角度信息
		 */
		this.Gyroscope = {};

		/**
		 * 鼠标提示的循环处理
		 */
		this.MouseTitle = null;

		/**
		 * 鼠标提示的div
		 * @type {HTMLDivElement}
		 */
		this.titleDiv = null;

		this.runtime = runtime;

		/**
		 * Scratch 所使用的 canvas，获取不到返回 null
		 * @return {HTMLCanvasElement | null}
		 */
		this.canvas = () => {
			try {
				const { canvas } = this.runtime.renderer;
				if (canvas instanceof HTMLCanvasElement) {
					return canvas.parentElement;
				}
				return null;
			} catch (err) {
				return null;
			}
		};

		this.canvasSelf = () => {
			try {
				const { canvas } = this.runtime.renderer;
				if (canvas instanceof HTMLCanvasElement) {
					return canvas;
				}
				return null;
			} catch (err) {
				return null;
			}
		};

		if (this.canvas() === null) {
			console.error('当前页面不支持多指触控/全屏，请前往作品详情页体验完整作品！');
			// 注意：在提示之后，扩展仍然在运行。需要在后面引用 Canvas 的部分进行判断。
		}
		this._addevent();

		this._formatMessage = runtime.getFormatMessage({
			'zh-cn': {
				'WitCatMouse.copythis': '复制以下内容：',
				'WitCatMouse.name': '白猫的高级鼠标',
				'WitCatMouse.name.1': '高级鼠标',
				'WitCatMouse.name.2': '手机端',
				'WitCatMouse.set': '[set]右键菜单',
				'WitCatMouse.set.1': '启用',
				'WitCatMouse.set.2': '禁用',
				'WitCatMouse.when': '鼠标[key]被按下',
				'WitCatMouse.key.1': '左键',
				'WitCatMouse.key.2': '中键',
				'WitCatMouse.key.3': '右键',
				'WitCatMouse.key.4': '前侧键',
				'WitCatMouse.key.5': '后侧键',
				'WitCatMouse.mouseuse': '[mouseuse]鼠标',
				'WitCatMouse.mouseuse.1': '锁定',
				'WitCatMouse.mouseuse.2': '释放',
				'WitCatMouse.acceleration': '鼠标[way]速度', // 速度和加速度的区别
				'WitCatMouse.way.1': 'X',
				'WitCatMouse.way.2': 'Y',
				'WitCatMouse.way.3': 'Z',
				'WitCatTouch.down': '按下的手指数量',
				'WitCatTouch.istouch': '碰到手指[num]?',
				'WitCatTouch.touchs': '碰到的手指',
				'WitCatTouch.num': '第[num]个手指的[type]',
				'WitCatTouch.info': '手指[num]的[type]',
				'WitCatTouch.type.1': 'X',
				'WitCatTouch.type.2': 'Y',
				'WitCatTouch.type.3': 'ID',
				'WitCatMouse.fill': '[set]沉浸式全屏',
				'WitCatMouse.whenoutfill': '当退出全屏',
				'WitCatMouse.isfill': '全屏?',
				'WitCatMouse.fillask.1': '作品请求沉浸式全屏，是否同意？\n',
				'WitCatMouse.fillask.2': '/3次连续拒绝后将不再提示\n您仍可以使用 esc 切换沉浸式全屏状态',
				'WitCatMouse.setfill': '⚠️(危)设置分辨率高设为[num]',
				'WitCatMouse.resolution': '当前分辨率高',
				'WitCatMouse.cantouch': '设备支持[type]?',
				'WitCatMouse.types.1': '触屏',
				'WitCatMouse.types.2': '鼠标',
				'WitCatMouse.IsMobile': '移动设备?',
				'WitCatMouse.cursor': '更改鼠标的样式为[cursor]',
				'WitCatMouse.cursor.1': '默认',
				'WitCatMouse.cursor.2': '文本',
				'WitCatMouse.cursor.3': '十字移动',
				'WitCatMouse.cursor.4': '上下移动',
				'WitCatMouse.cursor.5': '左右移动',
				'WitCatMouse.cursor.6': '禁止',
				'WitCatMouse.cursor.7': '手指',
				'WitCatMouse.cursor.8': '加载',
				'WitCatMouse.cursor.9': '等待',
				'WitCatMouse.cursor.10': '帮助',
				'WitCatMouse.cursor.11': '竖向文本',
				'WitCatMouse.cursor.12': '十字准星',
				'WitCatMouse.cursorurl': '更改鼠标的样式为X[x]Y[y]data url[text]',
				'WitCatMouse.cursorstyle': '更改鼠标的样式为X[x]Y[y]大小[size]角色[s]的第[shape]造型',
				'WitCatMouse.url': '上传ico并获得data url',
				'WitCatMouse.click': '点击',
				'WitCatMouse.dclick': '双击',
				'WitCatMouse.mouse': '鼠标被[way]?',
				'WitCatMouse.mousetd': '当鼠标[key]按住[time]秒',
				'WitCatMouse.mouset': '鼠标[key]按下时长(秒)',
				'WitCatMouse.docs': '📖拓展教程',
				'WitCatMouse.mousewheel': '鼠标滚轮速度',
				'WitCatMouse.gyroscope': '当前[p]轴角度',
				'WitCatMouse.title': '设置鼠标提示[text]',
				'WitCatMouse.titlenow': '[show]鼠标提示[text]',
				'WitCatMouse.show.1': '显示',
				'WitCatMouse.show.2': '隐藏',
			},
			en: {
				'WitCatMouse.copythis': 'Copy the following text:',
				'WitCatMouse.name': 'WitCat’s Mouse',
				'WitCatMouse.name.1': 'more mouse',
				'WitCatMouse.name.2': 'Mobile terminal',
				'WitCatMouse.set': '[set]right-click menu',
				'WitCatMouse.set.1': 'Enable',
				'WitCatMouse.set.2': 'Disable',
				'WitCatMouse.when': 'mouse[key]down?',
				'WitCatMouse.key.1': 'left button',
				'WitCatMouse.key.2': 'middle button',
				'WitCatMouse.key.3': 'right button',
				'WitCatMouse.key.4': 'first side button',
				'WitCatMouse.key.5': 'second side button',
				'WitCatMouse.mouseuse': '[mouseuse]mouse',
				'WitCatMouse.mouseuse.1': 'Lock',
				'WitCatMouse.mouseuse.2': 'Release',
				'WitCatMouse.acceleration': 'mouse[way]speed',
				'WitCatMouse.way.1': 'X',
				'WitCatMouse.way.2': 'Y',
				'WitCatTouch.name': 'Touch',
				'WitCatTouch.down': 'Finger count',
				'WitCatTouch.istouch': 'Touch finger[num]?',
				'WitCatTouch.touchs': 'Touching fingers',
				'WitCatTouch.num': '[type]of finger[num]',
				'WitCatTouch.info': '[type] of finger [num]',
				'WitCatTouch.type.1': 'X',
				'WitCatTouch.type.2': 'Y',
				'WitCatTouch.type.3': 'ID',
				'WitCatMouse.fill': '[set]immersive full-screen',
				'WitCatMouse.whenoutfill': 'When exiting full screen',
				'WitCatMouse.isfill': 'full screen?',
				'WitCatMouse.fillask.1':
					'The project requests to turn on immersive full-screen, agree or not?\nWill stop asking if you keep on to reject for ',
				'WitCatMouse.fillask.2': '/3 times\nYou can also use esc to toggle immersive full-screen later.',
				'WitCatMouse.setfill': '⚠️(danger)Set resolution height to[num]',
				'WitCatMouse.resolution': 'Current high resolution',
				'WitCatMouse.cantouch': 'Device support[type]?',
				'WitCatMouse.types.1': 'touch screen',
				'WitCatMouse.types.2': 'mouse',
				'WitCatMouse.IsMobile': 'Mobile device?',
				'WitCatMouse.cursor': 'Change cursor style to[cursor]',
				'WitCatMouse.cursor.1': 'default',
				'WitCatMouse.cursor.2': 'text',
				'WitCatMouse.cursor.3': 'cross move',
				'WitCatMouse.cursor.4': 'move up and down',
				'WitCatMouse.cursor.5': 'move left and right',
				'WitCatMouse.cursor.6': 'not allowed',
				'WitCatMouse.cursor.7': 'pointer',
				'WitCatMouse.cursor.8': 'progress',
				'WitCatMouse.cursor.9': 'wait',
				'WitCatMouse.cursor.10': 'help',
				'WitCatMouse.cursor.11': 'vertical text',
				'WitCatMouse.cursor.12': 'crosshair',
				'WitCatMouse.cursorurl': 'Change the style of the mouse to X[x]Y[y]base64[text]',
				'WitCatMouse.cursorstyle': 'Change the mouse style to X[x]Y[y] size [size] character [s] shape[shape]',
				'WitCatMouse.url': 'upload ico and get base64',
				'WitCatMouse.click': 'click',
				'WitCatMouse.dclick': 'double-click',
				'WitCatMouse.mouse': 'mouse[way]?',
				'WitCatMouse.mousetd': 'When mouse[key]pressed[time]seconds',
				'WitCatMouse.mouset': 'mouse[key]hold time(sec)',
				'WitCatMouse.docs': '📖Tutorials',
				'WitCatInput.mousewheel': 'mouse wheel speed',
				'WitCatMouse.gyroscope': 'Current [p] axis Angle',
				'WitCatMouse.title': 'Set mouse prompts[text]',
				'WitCatMouse.titlenow': 'Let mouse prompts[text][show]',
				'WitCatMouse.show.1': 'show',
				'WitCatMouse.show.2': 'hide',
			},
		});
	}

	/**
	 * 翻译
	 * @param {string} id
	 * @returns {string}
	 */
	formatMessage(id) {
		return this._formatMessage({
			id,
			default: id,
			description: id,
		});
	}

	getInfo() {
		return {
			id: witcat_more_mouse_extensionId, // 拓展id
			name: this.formatMessage('WitCatMouse.name'), // 拓展名
			blockIconURI: witcat_more_mouse_icon,
			menuIconURI: witcat_more_mouse_icon,
			color1: '#8eace1',
			color2: '#86a2d4',
			blocks: [
				{
					blockType: 'button',
					text: this.formatMessage('WitCatMouse.docs'),
					onClick: this.docs,
				},
				{
					opcode: 'setfill',
					blockType: 'command',
					text: this.formatMessage('WitCatMouse.setfill'),
					arguments: {
						num: {
							type: 'number',
							defaultValue: '360',
						},
					},
				},
				{
					opcode: 'whenOutFill',
					blockType: 'hat',
					text: this.formatMessage('WitCatMouse.whenoutfill'),
					isEdgeActivated: false,
					arguments: {},
				},
				{
					opcode: 'isfill',
					blockType: 'Boolean',
					text: this.formatMessage('WitCatMouse.isfill'),
					arguments: {},
				},
				{
					opcode: 'fill',
					blockType: 'command',
					text: this.formatMessage('WitCatMouse.fill'),
					hideFromPalette: true,
					arguments: {
						set: {
							type: 'bool',
							menu: 'set',
						},
					},
				},
				{
					opcode: 'resolution',
					blockType: 'reporter',
					text: this.formatMessage('WitCatMouse.resolution'),
					arguments: {},
				},
				`---${this.formatMessage('WitCatMouse.name.1')}`,
				{
					opcode: 'title',
					blockType: 'command',
					text: this.formatMessage('WitCatMouse.title'),
					arguments: {
						text: {
							type: 'string',
							defaultValue: 'wit_cat!!!',
						},
					},
				},
				{
					opcode: 'titlenow',
					blockType: 'command',
					text: this.formatMessage('WitCatMouse.titlenow'),
					arguments: {
						text: {
							type: 'string',
							defaultValue: 'wit_cat!!!',
						},
						show: {
							type: 'string',
							menu: 'show',
						},
					},
				},
				{
					opcode: 'set',
					blockType: 'command',
					text: this.formatMessage('WitCatMouse.set'),
					arguments: {
						set: {
							type: 'bool',
							menu: 'set',
						},
					},
				},
				{
					opcode: 'when',
					blockType: 'Boolean',
					text: this.formatMessage('WitCatMouse.when'),
					arguments: {
						key: {
							type: 'string',
							menu: 'key',
						},
					},
				},
				{
					opcode: 'mouses',
					blockType: 'Boolean',
					text: this.formatMessage('WitCatMouse.mouse'),
					arguments: {
						way: {
							type: 'string',
							menu: 'ways',
						},
					},
				},
				{
					opcode: 'mousewheel',
					blockType: 'reporter',
					text: this.formatMessage('WitCatMouse.mousewheel'),
					arguments: {},
				},
				{
					opcode: 'mouse',
					blockType: 'hat',
					text: this.formatMessage('WitCatMouse.mouse'),
					arguments: {
						way: {
							type: 'string',
							menu: 'ways',
						},
					},
				},
				{
					opcode: 'mousetd',
					blockType: 'Boolean',
					text: this.formatMessage('WitCatMouse.mousetd'),
					arguments: {
						key: {
							type: 'number',
							menu: 'key',
						},
						time: {
							type: 'number',
							defaultValue: '1',
						},
					},
				},
				{
					opcode: 'mousetds',
					blockType: 'hat',
					text: this.formatMessage('WitCatMouse.mousetd'),
					arguments: {
						key: {
							type: 'number',
							menu: 'key',
						},
						time: {
							type: 'number',
							defaultValue: '1',
						},
					},
				},
				{
					opcode: 'mouset',
					blockType: 'reporter',
					text: this.formatMessage('WitCatMouse.mouset'),
					arguments: {
						key: {
							type: 'number',
							menu: 'key',
						},
					},
				},
				{
					blockType: 'button',
					text: this.formatMessage('WitCatMouse.url'),
					// 这里的 bind 必须，因为 this.url 里面引用了 this
					onClick: this.url.bind(this),
				},
				{
					opcode: 'cursor',
					blockType: 'command',
					text: this.formatMessage('WitCatMouse.cursor'),
					arguments: {
						cursor: {
							type: 'string',
							menu: 'cursor',
						},
					},
				},
				{
					opcode: 'cursorurl',
					blockType: 'command',
					text: this.formatMessage('WitCatMouse.cursorurl'),
					arguments: {
						x: {
							type: 'number',
							defaultValue: '0',
						},
						y: {
							type: 'number',
							defaultValue: '0',
						},
						text: {
							type: 'string',
							defaultValue: 'base64:ico',
						},
					},
				},
				{
					opcode: 'cursorStyle',
					blockType: 'command',
					text: this.formatMessage('WitCatMouse.cursorstyle'),
					arguments: {
						x: {
							type: 'number',
							defaultValue: '0',
						},
						y: {
							type: 'number',
							defaultValue: '0',
						},
						size: {
							type: 'number',
							defaultValue: '64',
						},
						s: {
							type: 'string',
							menu: 'targetListMenu',
						},
						shape: {
							type: 'number',
							defaultValue: '1',
						},
					},
				},
				{
					opcode: 'mouseuse',
					blockType: 'command',
					text: this.formatMessage('WitCatMouse.mouseuse'),
					arguments: {
						mouseuse: {
							type: 'string',
							menu: 'mouseuse',
						},
					},
				},
				{
					opcode: 'acceleration',
					blockType: 'reporter',
					text: this.formatMessage('WitCatMouse.acceleration'),
					arguments: {
						way: {
							type: 'string',
							menu: 'way',
						},
					},
				},
				`---${this.formatMessage('WitCatMouse.name.2')}`,
				{
					opcode: 'down',
					blockType: 'reporter',
					text: this.formatMessage('WitCatTouch.down'),
					arguments: {},
				},
				{
					opcode: 'num',
					blockType: 'reporter',
					text: this.formatMessage('WitCatTouch.num'),
					arguments: {
						num: {
							type: 'number',
							defaultValue: '1',
						},
						type: {
							type: 'string',
							menu: 'type',
						},
					},
				},
				{
					opcode: 'info',
					blockType: 'reporter',
					text: this.formatMessage('WitCatTouch.info'),
					arguments: {
						num: {
							type: 'string',
							defaultValue: '0',
						},
						type: {
							type: 'string',
							menu: 'type',
						},
					},
				},
				{
					opcode: 'isTouch',
					blockType: 'Boolean',
					text: this.formatMessage('WitCatTouch.istouch'),
					arguments: {
						num: {
							type: 'string',
							defaultValue: '0',
						},
					},
				},
				{
					opcode: 'touchs',
					blockType: 'reporter',
					text: this.formatMessage('WitCatTouch.touchs'),
					arguments: {},
				},
				{
					opcode: 'cantouch',
					blockType: 'Boolean',
					text: this.formatMessage('WitCatMouse.cantouch'),
					arguments: {
						type: {
							type: 'string',
							menu: 'types',
						},
					},
				},
				{
					opcode: 'IsMobile',
					blockType: 'Boolean',
					text: this.formatMessage('WitCatMouse.IsMobile'),
					arguments: {},
				},
				{
					opcode: 'gyroscope',
					blockType: 'reporter',
					text: this.formatMessage('WitCatMouse.gyroscope'),
					hideFromPalette: true,
					arguments: {
						p: {
							type: 'string',
							menu: 'rot',
						},
					},
				},
			],
			menus: {
				key: [
					{
						text: this.formatMessage('WitCatMouse.key.1'),
						value: '0',
					},
					{
						text: this.formatMessage('WitCatMouse.key.2'),
						value: '1',
					},
					{
						text: this.formatMessage('WitCatMouse.key.3'),
						value: '2',
					},
					{
						text: this.formatMessage('WitCatMouse.key.4'),
						value: '3',
					},
					{
						text: this.formatMessage('WitCatMouse.key.5'),
						value: '4',
					},
				],
				cursor: {
					acceptReporters: true,
					items: [
						{
							text: this.formatMessage('WitCatMouse.cursor.1'),
							value: 'default',
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.2'),
							value: 'text',
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.3'),
							value: 'move',
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.4'),
							value: 'n-resize',
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.5'),
							value: 'e-resize',
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.6'),
							value: 'not-allowed',
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.7'),
							value: 'pointer',
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.8'),
							value: 'progress',
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.9'),
							value: 'wait',
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.10'),
							value: 'help',
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.11'),
							value: 'vertical-text',
						},
						{
							text: this.formatMessage('WitCatMouse.cursor.12'),
							value: 'crosshair',
						},
					],
				},
				set: [
					{
						text: this.formatMessage('WitCatMouse.set.1'),
						value: 'true',
					},
					{
						text: this.formatMessage('WitCatMouse.set.2'),
						value: 'false',
					},
				],
				way: [
					{
						text: this.formatMessage('WitCatMouse.way.1'),
						value: 'x',
					},
					{
						text: this.formatMessage('WitCatMouse.way.2'),
						value: 'y',
					},
				],
				rot: [
					{
						text: this.formatMessage('WitCatMouse.way.1'),
						value: 'x',
					},
					{
						text: this.formatMessage('WitCatMouse.way.2'),
						value: 'y',
					},
					{
						text: this.formatMessage('WitCatMouse.way.3'),
						value: 'z',
					},
				],
				ways: [
					{
						text: this.formatMessage('WitCatMouse.click'),
						value: 'click',
					},
					{
						text: this.formatMessage('WitCatMouse.dclick'),
						value: 'dclick',
					},
				],
				type: [
					{
						text: this.formatMessage('WitCatTouch.type.1'),
						value: 'x',
					},
					{
						text: this.formatMessage('WitCatTouch.type.2'),
						value: 'y',
					},
					{
						text: this.formatMessage('WitCatTouch.type.3'),
						value: 'ID',
					},
				],
				types: [
					{
						text: this.formatMessage('WitCatMouse.types.1'),
						value: 'ontouchstart',
					},
					{
						text: this.formatMessage('WitCatMouse.types.2'),
						value: 'onmousedown',
					},
				],
				mouseuse: [
					{
						text: this.formatMessage('WitCatMouse.mouseuse.1'),
						value: 'lock',
					},
					{
						text: this.formatMessage('WitCatMouse.mouseuse.2'),
						value: 'release',
					},
				],
				show: [
					{
						text: this.formatMessage('WitCatMouse.show.1'),
						value: 'true',
					},
					{
						text: this.formatMessage('WitCatMouse.show.2'),
						value: 'false',
					},
				],
				targetListMenu: {
					items: "buildTargetListMenu"
				}
			},
		};
	}

	/**
	 * buildTargetListMenu菜单
	 * @returns 菜单
	 */
	buildTargetListMenu() {
		return this._spriteMenu();
	}

	/**
	 * 从runtime获取菜单
	 * @returns 菜单
	 */
	_spriteMenu() {
		let e = [];
		return this.runtime.targets.forEach((function (t) {
			t.isOriginal && !t.isStage && e.push({
				text: t.sprite.name,
				value: t.sprite.name
			})
		})), 0 === e.length && e.push({
			text: this.formatMessage({
				id: "GandiAsyncAssetManager.noneSprite",
				default: "none sprite"
			}),
			value: ""
		}), e
	}

	/**
	 * 启用右键菜单？
	 * @param {object} args
	 * @param {SCarg} args.set
	 */
	set(args) {
		const canvas = this.canvas();
		if (canvas === null) {
			return;
		}
		// 在把自己的方法设为给其他事件/函数的回调时加上 bind(this) 是很有必要的，
		// 确保回调函数触发时，里面的 this 指向自己。
		// 不过回调函数里面没有用到 this，所以是否有这个 bind 没有区别。
		// 如果加上了 bind，因为每次 bind() 都会生成一个新函数，
		// removeEventListener 的时候就会因为函数不一致导致 remove 不掉，
		// 需要提前把 bind 过的函数设为某类内变量。
		if (args.set === 'false') {
			canvas.addEventListener('contextmenu', this._nocontextmenu);
		} else {
			canvas.removeEventListener('contextmenu', this._nocontextmenu);
		}
	}

	/**
	 * 禁用右键菜单用的事件捕获函数
	 * @param {Event} event
	 */
	_nocontextmenu(event) {
		// 阻止右键菜单
		event.preventDefault();
	}

	/**
	 * 按下判断
	 * @param {object} args
	 * @param {SCarg} args.key
	 */
	when(args) {
		return this.button[Number(args.key)] === 'down';
	}

	/**
	 * 控制鼠标
	 * @param {object} args
	 * @param {SCarg} args.mouseuse
	 */
	mouseuse(args) {
		if (args.mouseuse === 'release') {
			document.exitPointerLock();
		} else {
			document.body.requestPointerLock();
		}
	}

	/**
	 * 鼠标移动量
	 * @param {object} args
	 * @param {SCarg} args.way
	 * @returns {number}
	 */
	acceleration(args) {
		if (args.way === 'x') {
			return this.xMouse;
		}
		return -this.yMouse;
	}

	/**
	 * 手指数量
	 * @returns {number}
	 */
	down() {
		return this.touch.length;
	}

	/**
	 * 坐标
	 * @param {object} args
	 * @param {SCarg} args.num 手指编号
	 * @param {SCarg} args.type 数据类型 "x"|"y"|"identifier"
	 * @returns {number|string}
	 */
	num(args) {
		const canvas = this.canvas();
		if (canvas === null) {
			return 0;
		}
		const touch1 = this.touch[Number(args.num) - 1];
		if (touch1 !== undefined) {
			if (args.type === 'x') {
				return this.runtime.stageWidth * ((touch1.clientX - canvas.getBoundingClientRect().left) / canvas.offsetWidth);
			}
			if (args.type === 'y') {
				return this.runtime.stageHeight * ((touch1.clientY - canvas.getBoundingClientRect().top) / canvas.offsetHeight);
			}
			return touch1.identifier;
		}
		return 0;
	}

	/**
	 * 坐标
	 * @param {object} args
	 * @param {SCarg} args.num 手指ID
	 * @param {SCarg} args.type 数据类型 "x"|"y"|"identifier"
	 * @returns {number|string}
	 */
	info(args) {
		const canvas = this.canvas();
		if (canvas === null) {
			return 0;
		}
		for (let i = 0; i < this.touch.length; i++) {
			if (this.touch[i]["identifier"] === args.num) {
				if (this.touch[i] !== undefined) {
					if (args.type === 'x') {
						return this.runtime.stageWidth * ((this.touch[i].clientX - canvas.getBoundingClientRect().left) / canvas.offsetWidth);
					}
					if (args.type === 'y') {
						return this.runtime.stageHeight * ((this.touch[i].clientY - canvas.getBoundingClientRect().top) / canvas.offsetHeight);
					}
					return touch1.identifier;
				}
			}
		}
		return 0;
	}

	/**
	 * 全屏
	 * @deprecated
	 */
	fill(args) {
		console.warn('全屏因浏览器兼容问题已下线，并不会再上线\nFull screen has been taken offline due to browser compatibility issues. And never back online.')
	}

	whenOutFill() {
		return true;
	}

	isfill() {
		return Boolean(document.fullscreenElement);
	}

	/**
	 * 设置分辨率
	 * @deprecated
	 */
	setfill(args) {
		if (Date.now() - this.LastSet > 1000) {
			this.LastSet = Date.now();
			const canvas = this.canvasSelf();
			if (canvas === null) {
				return 0;
			}
			if (Number(args.num) < window.screen.height) {
				this.runtime.renderer.resize((Number(args.num) * this.runtime.stageWidth) / this.runtime.stageHeight, Number(args.num));
			} else {
				console.warn("分辨率超过屏幕，将产生额外性能消耗\nResolution exceeding the screen will incur additional performance costs");
			}
		} else {
			console.warn("设置分辨率太过频繁\nSetting the resolution too often");
		}
	}

	/**
	 * 当前分辨率
	 * @returns {number}
	 */
	resolution() {
		const canvas = this.canvasSelf();
		if (canvas === null) {
			return 0;
		}
		return canvas.height;
	}

	/**
	 * 设备是否支持触屏/鼠标
	 * @param {object} args
	 * @param {SCarg} args.type
	 * @returns {boolean}
	 */
	cantouch(args) {
		return args.type in document.documentElement;
	}

	/**
	 * 是否是手机
	 * @returns {boolean}
	 */
	IsMobile() {
		return /Android|iPhone|iPad|iPod|BlackBerry|webOS|Windows Phone|SymbianOS|IEMobile|Opera Mini/i.test(
			navigator.userAgent
		);
	}

	/**
	 * 设置光标样式
	 * @param {object} args
	 * @param {SCarg} args.cursor 样式
	 */
	cursor(args) {
		const canvasParent = this.canvas()?.parentNode?.parentNode?.parentNode;
		if (canvasParent === null || canvasParent === undefined) {
			return;
		}
		canvasParent.style.cursor = String(args.cursor);
	}

	/**
	 * 设置光标为url
	 * @param {object} args
	 * @param {SCarg} args.text 样式
	 * @param {SCarg} args.x x偏移
	 * @param {SCarg} args.y y偏移
	 */
	cursorurl(args) {
		const canvasParent = this.canvas()?.parentNode?.parentNode?.parentNode;
		if (canvasParent === null || canvasParent === undefined) {
			return;
		}
		let url = String(args.text);
		const x = Number(args.x);
		const y = Number(args.y);
		// 针对 url() 里的语法，转义。
		url = url.replace(/"/g, '%22').replace(/\n/g, '%0D').replace(/\r/g, '%0A').replace(/\0/g, '%00');
		// 实际上 cursorurl 处可以直接使用 正常的 url 和 data url。
		// 不需要特地转换。
		canvasParent.style.cursor = `url("${url}") ${x} ${y}, auto`;
	}

	/**
	 * 设置光标为造型
	 * @param {object} args
	 * @param {SCarg} args.s 目标角色
	 * @param {SCarg} args.size 大小
	 * @param {SCarg} args.x x偏移
	 * @param {SCarg} args.y y偏移
	 */
	cursorStyle(args) {
		const canvasParent = this.canvas()?.parentNode?.parentNode?.parentNode;
		if (canvasParent === null || canvasParent === undefined) {
			return;
		}
		const targetRoleName = String(args.s);

		const x = Number(args.x);
		const y = Number(args.y);
		const size = Number(args.size);
		const targetCostumeIndex = Number(args.shape - 1);
		const targetSprite = this.runtime.targets.find((v) => { return v.sprite.name === targetRoleName });
		if (targetSprite) {
			try {
				const targetCostume = targetSprite.sprite.costumes_[targetCostumeIndex];

				const costumeURL = this.Uint8ArrayToString(targetCostume.asset.data);
				const width = targetCostume.size[0];
				const height = targetCostume.size[1];

				let sizes = 0;
				if (width < height) {
					sizes = size / height;
				}
				else {
					sizes = size / width;
				}

				const svgDataUri = (targetCostume.asset.assetType.contentType === 'image/png' ? 'data:image/png;base64,' : 'data:image/svg+xml;base64,') + btoa(costumeURL);
				const canvas = document.createElement('canvas');
				canvas.width = size;
				canvas.height = size;
				const ctx = canvas.getContext('2d');

				const svgImage = new Image();
				svgImage.src = svgDataUri;
				svgImage.onload = function () {
					ctx.drawImage(svgImage, 0, 0, width * sizes, height * sizes);
					const icoDataUri = canvas.toDataURL('image/x-icon');

					canvasParent.style.cursor = `url("data:image/x-icon;${icoDataUri.split(";")[1]}") ${x} ${y}, auto`;
				};
			}
			catch (e) {
				console.error("Target modeling does not exist: " + targetCostumeIndex + "\nmore info：" + "\n" + e);
			}
		} else {
			console.error("Target role not found: " + targetRoleName);
		}
	}

	/**
	 * 鼠标提示文案
	 * @param {Object} args 
	 */
	title(args) {
		const canvasParent = this.canvas()?.parentNode?.parentNode?.parentNode;
		if (canvasParent === null || canvasParent === undefined) {
			return;
		}
		canvasParent.title = String(args.text);
	}

	titlenow(args) {
		const canvas = this.canvas();
		if (canvas === null) {
			return;
		}
		if (args.show === 'true') {
			if (this.titleDiv == null) {
				this.titleDiv = document.createElement("div");
				this.titleDiv.innerText = String(args.text);
				this.titleDiv.style = `transition: transform 0.2s ease-in-out;transform: scale(0, 0);z-index: 10000;border:1px solid #000000 ;transform-origin:0px 0px;border-radius:10px;background-color:#ffffff;padding:5px;position:fixed;top:${this.MouseY + 10}px;left:${this.MouseX + 10}px`;
				this.MouseTitle = setInterval(() => {
					this.titleDiv.style.top = (this.MouseY + 10) + 'px';
					this.titleDiv.style.left = (this.MouseX + 10) + 'px';
				}, 1);
				canvas.append(this.titleDiv);
				setTimeout(() => {
					this.titleDiv.style.transform = 'scale(1, 1)';
				}, 10);
			}
			else if (String(args.text) !== this.titleDiv.innerText) {
				setTimeout(() => {
					this.titleDiv.style.transform = 'scale(0, 0)';
					setTimeout(() => {
						this.titleDiv.innerText = String(args.text);
						this.titleDiv.style.transform = 'scale(1, 1)';
					}, 200);
				}, 200);
			}
		}
		else {
			if (this.MouseTitle !== null) {
				clearInterval(this.MouseTitle);
				this.MouseTitle = null;
				this.titleDiv.style.transform = 'scale(0, 0)';
				setTimeout(() => {
					document.body.removeChild(this.titleDiv);
					this.titleDiv = null;
				}, 200);
			}
		}
	}

	/**
	 * 将Uint8Array编码的文本转换为string
	 * @param {Uint8Array} fileData 需要转换的文件
	 * @returns {string} 转换后的文本
	 */
	Uint8ArrayToString(fileData) {
		let dataString = "";
		for (let i = 0; i < fileData.length; i++) {
			dataString += String.fromCharCode(fileData[i]);
		}
		return dataString
	}

	/**
	 * 打开文件选择框
	 * @param {string} accept 接受的文件扩展名
	 * @param {boolean} multiple 接受多个文件
	 * @return {Promise<File[]>} [异步地]返回选择后的文件列表input.files转换成的数组(可能没有文件)
	 */
	_inputfileclick(accept, multiple) {
		return new Promise((resolve, reject) => {
			const input = document.createElement('input');
			input.type = 'file';
			input.accept = accept;
			input.style.display = 'none';
			input.multiple = multiple;
			input.click();
			input.addEventListener(
				'change',
				() => {
					if (input.files === null) {
						reject(new Error('不应该看到这个'));
					} else {
						// 返回了关键的 input.files，而不是整个 input。
						// 之后如果要考虑“读取素材库文件”，“拖动导入文件”等
						// 只能获得 Blob/File 的情况，可以方便适配
						// 这里加 Array.from 是因为 input.files 是 FileList，
						// 不是 File[]，一些数组拥有的功能它没有。虽然一般情况下
						// 不会注意到区别，但是类型检查会把这种情况查出来。
						resolve(Array.from(input.files));
					}
				},
				{ once: true }
			); // 只触发一次
			window.addEventListener(
				'focus',
				() => {
					setTimeout(() => {
						if (input.files === null) {
							reject(new Error('不应该看到这个'));
						} else {
							resolve(Array.from(input.files));
						}
					}, 1000);
				},
				{ once: true }
			); // 只触发一次
		});
	}

	/**
	 * 读取文件
	 * @param {File|Blob} file File 或者 Blob
	 * @param {"arraybuffer"|"dataurl"|"text"} mode 读取模式
	 * @return {Promise<string|ArrayBuffer|null>} [异步地]返回读取后的内容
	 */
	_readerasync(file, mode) {
		return new Promise((resolve, reject) => {
			const reader = new FileReader();
			reader.onload = () => {
				resolve(reader.result);
			};
			reader.onerror = (e) => {
				reject(e);
			};
			switch (mode) {
				case 'arraybuffer':
					reader.readAsArrayBuffer(file);
					break;
				case 'dataurl':
					reader.readAsDataURL(file);
					break;
				case 'text':
					reader.readAsText(file);
					break;
				default:
					reject(new Error('mode 错误: 应该是 arraybuffer, dataurl 或者 text'));
			}
		});
	}

	/**
	 * 获取移动端设备角度
	 * @param {JSON} args 
	 */
	gyroscope(args) {
		try {
			switch (args.p) {
				case 'x':
					return this.Gyroscope.beta;
				case 'y':
					return this.Gyroscope.gamma;
				case 'z':
					return this.Gyroscope.alpha;
			}
			return "";
		}
		catch (e) {
			//设备可能是电脑
			return "";
		}
	}

	/**
	 * 打开ico文件
	 */
	async url() {
		const file = (await this._inputfileclick('.ico', false))[0];
		if (file !== undefined) {
			// 加一个扩展名判断？
			const dataurl = String(await this._readerasync(file, 'dataurl'));
			let div = document.createElement('div');
			div.style.position = 'fixed';
			div.style.top = '0px';
			div.style.left = '0px';
			div.style.width = '100%';
			div.style.height = '100%';
			div.style.zIndex = '9999';
			div.style.transition = 'all 0.2s ease-out';
			div.style.backgroundColor = '#00000000';
			div.innerHTML = `
<div id="myModal" class="modal">
<div class="modals">
  <span class="close">
      &times;
  </span>
  <h5>${this.formatMessage('WitCatMouse.copythis')}</h5>
  <div class="modal-content">
  <p>${dataurl}</p>
  </div>
</div>
</div>
<style>
.modal{
	height:0%;
	transition:all 0.2s ease-out;
}

.modal-content {
	margin-top:16px;
	height:calc(100% - 16px);
	overflow: scroll;
}
.modals{
    background-color: #00000000;
    margin: 15% auto; 
    padding: 20px;
	border-radius:20px;
    width: 50%; 
    height:50%;
    position:relative;
}
 
.modal-content::-webkit-scrollbar-corner {
  background-color: transparent;
}

.modal-content p,.modals h5 {
    color: var(--theme-text-primary);
}

.modals h5 {
	font-size: 20px;
}

.close {
  cursor: pointer;
  position:absolute;
  top:0;
  right:10px;
  color:#aaa;
  font-size:28px;
  font-weight:bold;
}

//关闭特效
.close:hover,
.close:focus {
    color: black;
    text-decoration: none;
}

</style>
`;
			document.body.appendChild(div);

			let modal = document.getElementById('myModal');
			let span = document.querySelector('.close');
			//创建点击事件
			span.onclick = function () {
				div.style.backgroundColor = '#00000000';
				modal.style.height = '0%';
				document.getElementsByClassName('modals')[0].style.backgroundColor = '#00000000';
				setTimeout(() => {
					div.remove();
				}, 180);
			}
			// 在用户点击其他地方时，关闭弹窗
			document.addEventListener("click", function (event) {
				if (event.target == modal) {
					div.style.backgroundColor = '#00000000';
					modal.style.height = '0%';
					document.getElementsByClassName('modals')[0].style.backgroundColor = '#00000000';
					setTimeout(() => {
						div.remove();
					}, 180);
				}
			})
			setTimeout(() => {
				div.style.backgroundColor = 'var(--theme-scrollbar-color)';
				modal.style.height = '80%';
				document.getElementsByClassName('modals')[0].style.backgroundColor = 'var(--theme-color-300)';
			}, 100);
		}
	}

	/**
	 * 打开教程
	 */
	docs() {
		const a = document.createElement('a');
		a.href = 'https://www.ccw.site/post/c36aa805-b29d-48da-aba1-468a6cf80bfa';
		a.rel = 'noopener noreferrer';
		a.target = '_blank';
		a.click();
	}

	/**
	 * 鼠标点击/双击
	 * @param {object} args
	 * @param {SCarg} args.way 点击/双击
	 * @returns {boolean}
	 */
	mouse(args) {
		if (args.way === 'click') {
			return this.click !== false;
		}
		if (args.way === 'dclick') {
			return this.dclick !== false;
		}
		return false;
	}

	/**
	 * 鼠标滚轮速度
	 * @returns {number}
	 */
	mousewheel() {
		return this.MouseWheel;
	}

	/**
	 * 鼠标点击/双击(帽子积木)
	 * @param {object} args
	 * @param {SCarg} args.way 点击/双击
	 * @returns {boolean}
	 */
	mouses(args) {
		return this.mouse(args);
	}

	/**
	 * 判断鼠标键按下时长
	 * @param {object} args
	 * @param {SCarg} args.key 按键编号
	 * @param {SCarg} args.time 按键时长
	 * @returns {boolean}
	 */
	mousetd(args) {
		const mousetdkey = this.mousetdlist[Number(args.key)];
		if (mousetdkey !== undefined && mousetdkey !== '') {
			const time = Date.now() - (Number(args.time) * 1000 + mousetdkey);
			if (time >= -50 && time <= 50) {
				return true;
			}
		}
		return false;
	}

	/**
	 * 判断是否碰到某个手指
	 * @param {*} args 
	 * @param {*} util 
	 * @returns 
	 */
	isTouch(args, util) {
		const canvas = this.canvas();
		for (let i = 0; i < this.touch.length; i++) {
			if (this.touch[i]["identifier"] === args.num) {
				if (this.touch[i] !== undefined) {
					let x = (this.touch[i].clientX - canvas.getBoundingClientRect().left);
					let y = (this.touch[i].clientY - canvas.getBoundingClientRect().top);
					return util.target.isTouchingPoint(x, y);
				}
			}
		}
		return false;
	}


	/**
	 * 返回碰到的手指ID列表
	 * @param {Object} args 
	 * @param {Object} util 
	 * @returns 
	 */
	touchs(args, util) {
		const canvas = this.canvas();
		let s = [];
		for (let i = 0; i < this.touch.length; i++) {
			let x = (this.touch[i].clientX - canvas.getBoundingClientRect().left);
			let y = (this.touch[i].clientY - canvas.getBoundingClientRect().top);
			if (util.target.isTouchingPoint(x, y)) {
				s.push(this.touch[i]["identifier"]);
			}
		}
		return JSON.stringify(s);
	}

	/**
	 * 判断鼠标键按下时长(帽子积木)
	 * @param {object} args
	 * @param {SCarg} args.key 按键编号
	 * @param {SCarg} args.time 按键时长
	 * @returns {boolean}
	 */
	mousetds(args) {
		return this.mousetd(args);
	}

	/**
	 * 鼠标被按下的时间
	 * @param {object} args
	 * @param {SCarg} args.key 按键编号
	 * @returns {number}
	 */
	mouset(args) {
		const mousetdkey = this.mousetdlist[Number(args.key)];
		if (mousetdkey !== undefined && mousetdkey !== '') {
			return (Date.now() - mousetdkey) / 1000;
		}
		return 0;
	}

	/**
	 * 复制触摸点数
	 * @param {TouchList} touches
	 */
	_copytouch(touches) {
		this.touch = Array.from(touches).map((touch) => {
			return {
				clientX: touch.clientX,
				clientY: touch.clientY,
				identifier: touch.identifier,
			};
		});
	}

	/** 添加事件触发器 */
	_addevent() {
		const canvas = this.canvas();
		if (canvas === null) {
			return;
		}
		// 鼠标
		document.addEventListener('mousedown', (e) => {
			this.button[e.button] = 'down';
			this.mousetdlist[e.button] = Date.now();
			if (this.button[0] === 'down') {
				this.touch = [
					{
						clientX: e.clientX,
						clientY: e.clientY,
						identifier: 'mouse',
					},
				];
			}
		});
		document.addEventListener('mouseup', (e) => {
			this.button[e.button] = 'up';
			this.mousetdlist[e.button] = '';
			this.touch = [];
		});
		document.addEventListener('mousemove', (ev) => {
			if (this.button[0] === 'down') {
				this.touch = [
					{
						clientX: ev.clientX,
						clientY: ev.clientY,
						identifier: 'mouse',
					},
				];
			} else {
				this.touch = [];
			}
			this.MouseX = ev.clientX;
			this.MouseY = ev.clientY;
			this.xMouse = ev.movementX; // 获得鼠标指针的x移动量
			this.yMouse = ev.movementY; // 获得鼠标指针的y移动量
			if (this.timer !== null) {
				clearTimeout(this.timer);
			}
			this.timer = setTimeout(() => {
				this.xMouse = 0;
				this.yMouse = 0;
			}, 30);
		});
		// 多指触控
		canvas.addEventListener('touchstart', (e) => {
			// e.targetTouches 会随着时间改变，必须复制一份。
			this._copytouch(e.targetTouches);
			this.button[0] = 'down';
			this.mousetdlist[0] = Date.now();
		});
		canvas.addEventListener('touchmove', (e) => {
			if (e.targetTouches[0] !== undefined && this.touch[0] !== undefined) {
				this.xMouse = e.targetTouches[0].clientX - this.touch[0].clientX; // 获得手指的x移动量
				this.yMouse = e.targetTouches[0].clientY - this.touch[0].clientY; // 获得手指的y移动量
			}
			if (this.timer !== null) {
				clearTimeout(this.timer);
			}
			this.timer = setTimeout(() => {
				this.xMouse = 0;
				this.yMouse = 0;
			}, 30);
			// e.targetTouches 会随着时间改变，必须复制一份。
			this._copytouch(e.targetTouches);
		});
		canvas.addEventListener('touchend', (e) => {
			// e.targetTouches 会随着时间改变，必须复制一份。
			this._copytouch(e.targetTouches);
			this.mousetdlist[0] = '';
			this.button[0] = 'up';
		});
		document.addEventListener('click', () => {
			if (this.click !== false) {
				clearTimeout(this.click);
			}
			this.click = setTimeout(() => {
				this.click = false;
			}, 50);
		});
		document.addEventListener('dblclick', () => {
			if (this.dclick !== false) {
				clearTimeout(this.dclick);
			}
			this.dclick = setTimeout(() => {
				this.dclick = false;
			}, 50);
		});
		// 给页面绑定滑轮滚动事件
		document.addEventListener('wheel', (e) => {
			clearTimeout(this.timer);
			this.MouseWheel = e.deltaY;
			this.timer = setTimeout(() => {
				this.MouseWheel = 0;
			}, 30);
		}, { capture: true });
		window.addEventListener('deviceorientation', (e) => {
			this.Gyroscope = e;
		});
	}
}

window.tempExt = {
	Extension: WitCatMouse,
	info: {
		name: "WitCatMouse.name",
		description: "WitCatMouse.descp",
		extensionId: witcat_more_mouse_extensionId,
		iconURL: witcat_more_mouse_picture,
		insetIconURL: witcat_more_mouse_icon,
		featured: true,
		disabled: false,
		collaborator: "白猫 @ CCW"
	},
	l10n: {
		"zh-cn": {
			"WitCatMouse.name": "白猫的高级鼠标 V3.2",
			"WitCatMouse.descp": "更精准的控制鼠标/触屏/全屏！"
		},
		en: {
			"WitCatMouse.name": "WitCat’s Mouse V3.2",
			"WitCatMouse.descp": "More precise mouse/touch/full screen control!"
		}
	}
};

/**
 * 计算舞台在全屏/非全屏的大小
 * @param {Element} element 需要被计算中心点的角色
 * @param {Boolean} type 模式（true：最小化，false：全屏）
 */
function resizeElementInParent(element, type, types, aspectRatio) {
	let parentWidth, parentHeight;

	if (type) {
		let parent
		if (types === 'zoom') {
			parent = element.parentElement.parentElement;
		}
		else {
			parent = element.parentElement;
		}
		parentWidth = parent.clientWidth;
		parentHeight = parent.clientHeight;
	} else {
		parentWidth = document.body.clientWidth;
		parentHeight = document.body.clientHeight;
	}

	let elementWidth = element.offsetWidth;
	let elementHeight = element.offsetHeight;

	if (types === 'zoom') {
		let widthRatio = parentWidth / elementWidth;
		let heightRatio = parentHeight / elementHeight;
		let scale = Math.min(widthRatio, heightRatio);
		element.style.transform = 'scale(' + scale + ')';
	} else {
		if (parentWidth / parentHeight > aspectRatio) {
			element.style.height = parentHeight + 'px';
			element.style.width = parentWidth / (aspectRatio / (parentWidth / parentHeight)) + 'px';
		} else {
			element.style.width = parentWidth + 'px';
			element.style.height = parentHeight / (aspectRatio / (parentWidth / parentHeight)) + 'px';
		}
	}
}
